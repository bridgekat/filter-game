import FilterGame.Basis

set_option linter.unusedVariables false
set_option autoImplicit false

namespace FilterGame
variable {α : Type _}

/-!
# '≤' in filters and filter basis

We define '≤' in filters and filter basis in this file.
-/

/-
Now, we want to consider ≤ in filters.
When we say that a filter g ⊆ filter f, it means that f is finer than or equal to g.
Hence we can define f ≤ g if g ⊆ f(i.e. ∀ s ∈ g → s ∈ f). This is equivalent to say
any set of filter g contains some set of filter f. i.e. ∀ s ∈ g → (∃ t ∈ f, t ⊆ s)
We leave the proof of this equivalence as a puzzle below.

Remark:
In this context, being "finer" means having more sets that satisfy the conditions
for being in the filter. The definition captures the idea that g has, in some sense,
more detailed or refined information than f. This is analogous to the concept of refining
a partition or a grid in topology or analysis. For example, in calculus,
when we talk about partitions of an interval, a finer partition has more subintervals.
-/

-- Let's verify it satisfies partial order:
instance : PartialOrder (Filter α) :=
{ le          := fun f g ↦ ∀ s ∈ g, s ∈ f,
  le_antisymm := by intros a b hab hba; apply Filter.ext; intros s; exact ⟨hba s, hab s⟩
  le_refl     := by intros a s h; exact h
  le_trans    := by intros a b c hab hbc s hsc; exact hab s (hbc s hsc) }

theorem Filter.le_def (f g : Filter α) : f ≤ g ↔ ∀ s ∈ g, s ∈ f :=
  Iff.rfl

-- As mentioned above, this is equivalent to say
-- any set of filter G contains some set of filter F. i.e. ∀ u ∈ G → (∃ v ∈ F, v ⊆ u)
example (f g : Filter α) : f ≤ g ↔ (∀ s ∈ g, ∃ t ∈ f, t ⊆ s) := by
  apply Iff.intro
  . intros h s hs; exact ⟨s, h s hs, subset_rfl⟩
  . intros h s hs; have ⟨t, ht⟩ := h s hs; exact Filter.in_of_subset_in ht.1 ht.2

/-
Next, we want to consider how to define '≤' on filter basis.
Notice that the equivalence above is not always satisfied for filter basis.
Why? Hint: Look at which theorem you used in the proof of above example.

So, considering two filter basis B and C, we say B is finer than C if
any set of C contains some set of B, denoted as 'B ≤ᵇ C'.
We use '≤ᵇ' instead of '≤' here since it doesn't satisfy partial order.
i.e. if B ≤ C and C ≤ B, it doesn't always imply B = C.
-/

def Basis.le (b c : Basis α) :=
  ∀ s ∈ c, ∃ t ∈ b, t ⊆ s

infix:50 " ≤' " => Basis.le

theorem Basis.le_def (b c : Basis α) : b ≤' c ↔ (∀ s ∈ c, ∃ t ∈ b, t ⊆ s) :=
  Iff.rfl

-- Next, let's think about how to prove this:

/-- If filter base B is finer than filter base C then the filter generated by B is finer
than the filter generated by C. -/
theorem Basis.as_filter_le {b c : Basis α} (h : b ≤' c) : b.as_filter ≤ c.as_filter := by
  rw [Basis.le_def] at h
  simp_rw [Filter.le_def, Basis.in_as_filter_iff]
  intros s hs
  have ⟨t, ht⟩ := hs
  have ⟨u, hu⟩ := h t ht.1
  exact ⟨u, hu.1, subset_trans hu.2 ht.2⟩

-- Here is another puzzle:

/-- If B is a filter basis which generates filter F and G is any filter, then
G is finer than B if and only if G is finer than the filter generated by B. -/
theorem Filter.as_basis_le_iff (f : Filter α) (b : Basis α) : f.as_basis ≤' b ↔ f ≤ b.as_filter := by
  apply Iff.intro
  . intros h
    rw [← Filter.as_basis_as_filter_eq f]
    exact Basis.as_filter_le h
  . intros h
    rw [Basis.le_def]
    intros s hs
    have hs' := h s (Basis.in_as_filter_of_in hs)
    exact ⟨s, hs', subset_rfl⟩

/-- B ≤' C and C ≤' B if and only if the filter generated by B equals the filter
generated by C. -/
theorem Basis.le_and_le_iff_filter_eq (b c : Basis α) : b ≤' c ∧ c ≤' b ↔ b.as_filter = c.as_filter := by
  apply Iff.intro
  . intros h
    apply le_antisymm
    . exact Basis.as_filter_le h.1
    . exact Basis.as_filter_le h.2
  . suffices h : ∀ b c, Basis.as_filter b = Basis.as_filter c → b ≤' c
    . intros heq
      exact ⟨h _ _ heq, h _ _ heq.symm⟩
    intros b c hbc s hs
    have hs' := Basis.in_as_filter_of_in hs
    rw [← hbc] at hs'
    exact hs'

end FilterGame
