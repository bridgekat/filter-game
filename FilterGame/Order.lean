import FilterGame.Basis

set_option linter.unusedVariables false
set_option autoImplicit false

namespace FilterGame
variable {α : Type _}

/-!
# `≤` between filters and filter bases

In this world, we will define a partial order `≤` between filters, as well as
between filter bases.

A filter `f` is called "finer than or equal to" filter `g` when `g.sets` is a
subset of `f.sets`, and we write `f ≤ g` for it... Wait...

Yes, we are using `f ≤ g`, while in reality `f.sets` is bigger than `g.sets`.
Probably unfortunate, but it is a convention! A way to understand this is to
draw analogy between filters and partitions of an interval: a partition is
called "finer" when it contains more subintervals, because then the subintervals
have a smaller average length. A filter is called "finer" when it contains more
subsets, because then the differences between subsets becomes smaller.

We start by proving the aforementioned relation is indeed a partial order:
-/

instance : PartialOrder (Filter α) :=
{ le          := fun f g ↦ ∀ s ∈ g, s ∈ f
  le_antisymm := by intros a b hab hba; apply Filter.ext; intros s; exact ⟨hba s, hab s⟩
  le_refl     := by intros a s h; exact h
  le_trans    := by intros a b c hab hbc s hsc; exact hab s (hbc s hsc) }

theorem Filter.le_def (f g : Filter α) : f ≤ g ↔ ∀ s ∈ g, s ∈ f := by
  exact Iff.rfl

/-!
The "finer than or equal to" relation `f ≤ g` is actually equivalent to
saying that each set of `g` includes some set of `f`.

This gives another clue for the choice of `≤`.
-/

example (f g : Filter α) : f ≤ g ↔ (∀ s ∈ g, ∃ t ∈ f, t ⊆ s) := by
  apply Iff.intro
  . intros h s hs; exact ⟨s, h s hs, subset_rfl⟩
  . intros h s hs; have ⟨t, ht⟩ := h s hs; exact Filter.superset_mem ht.1 ht.2

/-!
Next, we consider defining `≤` between filter bases.

Note that if we keep using the same definition for filter bases, the above
equivalence is not always satisfied. Why? Hint: look at the properties you have
used in your proof.

So, for any two filter bases `b` and `c`, we instead consider `b` to be finer
than `c` when each set of `c` includes some set of `b`.
-/

def Basis.le (b c : Basis α) :=
  ∀ s ∈ c, ∃ t ∈ b, t ⊆ s

/-!
We use the symbol `≤'` to denote such a relation.

Note that this is not a partial order: in particular, `b ≤' c` and `c ≤' b`
does not necessarily imply `b = c`. (It does, however, imply that the filters
generated by `b` and `c` are equal, which will be shown later.)
-/

scoped infix:50 " ≤' " => Basis.le

theorem Basis.le_def (b c : Basis α) : b ≤' c ↔ (∀ s ∈ c, ∃ t ∈ b, t ⊆ s) := by
  exact Iff.rfl

--! Next, let's think about how to prove this:

/--
If filter basis `b` is finer than filter basis `c`, then the filter generated
by `b` is finer than the filter generated by `c`.
-/
theorem Basis.as_filter_le {b c : Basis α} (h : b ≤' c) : b.as_filter ≤ c.as_filter := by
  rw [Basis.le_def] at h
  simp_rw [le_def, Basis.mem_as_filter_def]
  intros s hs
  have ⟨t, ht⟩ := hs
  have ⟨u, hu⟩ := h t ht.1
  exact ⟨u, hu.1, subset_trans hu.2 ht.2⟩

--! Here is another puzzle:

/--
If filter basis `b` generates filter `f`, then any filter `g` (when viewed as
a basis) is finer than `b` if and only if `g` is finer than `f`.
-/
theorem Filter.as_basis_le_iff (f : Filter α) (b : Basis α) : f.as_basis ≤' b ↔ f ≤ b.as_filter := by
  apply Iff.intro
  . intros h
    rw [← as_basis_as_filter_eq_self f]
    exact Basis.as_filter_le h
  . intros h
    rw [Basis.le_def]
    intros s hs
    have hs' := h s (Basis.mem_as_filter_of_mem hs)
    exact ⟨s, hs', subset_rfl⟩

--! The final one!

/--
Given two filter bases `b` and `c`, `b ≤' c` and `c ≤' b` if and only if the
filter generated by `b` equals to the filter generated by `c`.
-/
theorem Basis.le_and_le_iff_filter_eq (b c : Basis α) : b ≤' c ∧ c ≤' b ↔ b.as_filter = c.as_filter := by
  apply Iff.intro
  . intros h
    apply le_antisymm
    . exact Basis.as_filter_le h.1
    . exact Basis.as_filter_le h.2
  . suffices h : ∀ b c, Basis.as_filter b = Basis.as_filter c → b ≤' c
    . intros heq
      exact ⟨h _ _ heq, h _ _ heq.symm⟩
    intros b c hbc s hs
    have hs' := Basis.mem_as_filter_of_mem hs
    rw [← hbc] at hs'
    exact hs'

end FilterGame
