import FilterGame.Solutions.Filter

set_option linter.unusedVariables false
set_option autoImplicit false

namespace FilterGame
variable {α : Type _}

/-!
# Filter bases

In this world, we will define filter bases and investigate their relationship
with filters.
-/

/--
Given a type `α`, a filter basis is a collection of sub**sets** of `α` which:

- contains at least one subset (the **sets** collection is **nonempty**),
- intersections of two member subsets include some member subset of the
  collection (**inter**sections include **mem**bers of **sets**).

We represent it in Lean as a new type, which "packages" the collection of
subsets, along with all the properties it should have.
-/
structure Basis (α : Type _) where
  sets                 : Set (Set α)
  sets_nonempty        : ∃ s, s ∈ sets
  inter_mem_sets {s t} : s ∈ sets → t ∈ sets → ∃ u ∈ sets, u ⊆ s ∩ t

/--
If we have a filter basis `b`, it is more convenient to write `s ∈ b` for
`s ∈ b.sets`. We now define this notation.
-/
instance : Membership (Set α) (Basis α) :=
  ⟨fun s b ↦ s ∈ b.sets⟩

/--
The definition of `∈`.
-/
@[simp]
theorem Basis.mem_def (b : Basis α) (s : Set α) : s ∈ b ↔ s ∈ b.sets := by
  exact Iff.rfl

/--
The definition of equality between filter bases.
-/
@[simp]
theorem Basis.eq_def (b c : Basis α) : b = c ↔ b.sets = c.sets := by
  apply Iff.intro
  . intro h; rw [h]
  . intro h; cases b; cases c; congr

/--
This is a simple corollary of the above lemmas, `Basis.mem_def` and
`Basis.eq_def`, and set extensionality, `Set.ext`.
-/
theorem Basis.ext_iff (b c : Basis α) : b = c ↔ (∀ s, s ∈ b ↔ s ∈ c) := by
  simp_rw [eq_def, mem_def, Set.ext_iff]

theorem Basis.ext {b c : Basis α} : (∀ s, s ∈ b ↔ s ∈ c) → b = c := by
  exact (ext_iff _ _).mpr

/--
The `sets` collection of any filter forms a filter basis as well.

This conversion is direct enough, that we can actually *view a filter as a
filter basis.*
-/
def Filter.as_basis (f : Filter α) : Basis α :=
{ sets := f.sets
  sets_nonempty := by
    exact ⟨Set.univ, univ_mem _⟩,
  inter_mem_sets := by
    intro s t hs ht
    exact ⟨s ∩ t, inter_mem hs ht, subset_rfl⟩ }

/--
The conversion `Filter.as_basis` preserves membership relations.
In other words, the conversion is indeed "direct enough".
-/
theorem Filter.mem_as_basis_def (f : Filter α) (t : Set α) : t ∈ Filter.as_basis f ↔ t ∈ f := by
  exact Iff.rfl

/-!
Actually, we can go the other way round and construct filters from filter bases:

The filter `f` generated by filter basis `b` is the collection of all sets `s`
satisfying that there exists a set `t ∈ b` which is also subset of `s`.
-/

/--
Now we prove that the aforementioned construction indeed gives a satisfactory
filter. We need to prove the three properties of filters:
-/
def Basis.as_filter (b : Basis α) : Filter α :=
{ sets := {s | ∃ t ∈ b, t ⊆ s}
  univ_mem_sets := by
    rw [Set.mem_iff]
    have ⟨s, hs⟩ := sets_nonempty b
    refine ⟨s, hs, Set.subset_univ _⟩
  superset_mem_sets := by
    intros s t hs h
    rw [Set.mem_iff] at hs ⊢
    have ⟨u, hu⟩ := hs
    exact ⟨u, hu.1, subset_trans hu.2 h⟩
  inter_mem_sets := by
    intros s t hs ht
    rw [Set.mem_iff] at *
    have ⟨u, hu⟩ := hs
    have ⟨v, hv⟩ := ht
    have ⟨w, hw⟩ := Basis.inter_mem_sets b hu.1 hv.1
    have ⟨hwu, hwv⟩ := Set.subset_inter_iff.mp hw.2
    refine ⟨w, hw.1, Set.subset_inter ?_ ?_⟩
    . exact subset_trans hwu hu.2
    . exact subset_trans hwv hv.2 }

/-!
These lemmas directly follow:
-/

theorem Basis.mem_as_filter_def (b : Basis α) (s : Set α) : s ∈ b.as_filter ↔ ∃ t ∈ b, t ⊆ s := by
  exact Iff.rfl

theorem Basis.mem_as_filter_of_mem {b : Basis α} {s : Set α} (h : s ∈ b) : s ∈ b.as_filter := by
  rw [Basis.mem_as_filter_def]
  exact ⟨s, h, subset_rfl⟩

/--
Finally, the filter generated by a filter (viewed as a filter basis) is
actually itself.
-/
theorem Filter.as_basis_as_filter_eq_self (f : Filter α) : f.as_basis.as_filter = f := by
  rw [eq_def]
  apply Set.ext; intros x
  simp_rw [← mem_def, Basis.mem_as_filter_def, mem_as_basis_def]
  apply Iff.intro
  . intros hx; have ⟨t, ht⟩ := hx; exact superset_mem ht.1 ht.2
  . intros hx; exact ⟨x, hx, subset_rfl⟩

end FilterGame
